# Data Structures and Algorithms Using Java Documentation

Welcome to the Data Structures and Algorithms Using Java Documentation repository! This repository contains documentation, explanations, and implementations of various data structures and algorithms in Java.

## Introduction

This documentation serves as a comprehensive guide to understanding fundamental data structures and algorithms commonly used in computer science and software development. Whether you're a beginner learning the basics or an experienced programmer looking for a quick reference, you'll find useful information here.

## Contents

1. [Bubble Sort](#bubble-sort)
2. [Merge Sort](#merge-sort)
3. [Quick Sort](#quick-sort)
4. [Binary Search Tree](#binary-search-tree) (To be made)
5. [Linked List](#linked-list) 
6. [Stack](#stack) 
7. [Queue](#queue)
8. [Selection Sort](#selection-sort)
9. [Insertion Sort](#insertion-sort)
10. [Linear Search](#linear-search)
11. [Recursion](#recursion)

## Bubble Sort

[Bubble Sort](/BubbleSort.java) is a simple sorting algorithm that repeatedly steps through the list, compares adjacent elements, and swaps them if they are in the wrong order.

## Merge Sort

[Merge Sort](/MergeSort.java) is a sorting algorithm that divides the array into two halves, recursively sorts the subarrays, and then merges them. It's efficient for large datasets and has a stable O(n log n) time complexity.

## Quick Sort

[Quick Sort](/QuickSort.java) is a sorting algorithm that divides the array into smaller subarrays, sorts them independently, and then combines them. It has an average-case time complexity of O(n log n) and is widely used due to its efficiency.

## Linked List
[Linked List](/MyLinkedList.java) is a linear data structure consisting of a sequence of elements, where each element points to the next element in the sequence. Unlike arrays, linked lists do not have a fixed size, and elements can be efficiently inserted or removed from any position in the list. There are different types of linked lists, such as singly linked lists, doubly linked lists, and circular linked lists, each with its own set of properties and operations.

## Stack
[Stack](/MyStack.java) is a linear data structure that follows the Last-In, First-Out (LIFO) principle, meaning that the last element added to the stack is the first one to be removed. It supports two main operations: push, which adds an element to the top of the stack, and pop, which removes the top element from the stack. Stacks are commonly used in algorithms involving recursive function calls, expression evaluation, and backtracking.

## Queue
[Queue](/MyQueue.java) is a linear data structure that follows the First-In, First-Out (FIFO) principle, meaning that the first element added to the queue is the first one to be removed. It supports two main operations: enqueue, which adds an element to the back of the queue, and dequeue, which removes the front element from the queue. Queues are commonly used in algorithms involving breadth-first search, task scheduling, and asynchronous processing.

## Selection Sort
[Selection Sort](/SelectionSort.java) is a simple sorting algorithm that repeatedly selects the minimum element from the unsorted portion of the array and swaps it with the first unsorted element. It has a time complexity of O(n^2) and is inefficient for large datasets.

## Insertion Sort
[Insertion Sort](/InsertionSort.java) is a simple sorting algorithm that builds the final sorted array one element at a time. It iterates through the array, moving each element to its correct position relative to the elements before it. It has a time complexity of O(n^2) and is efficient for small datasets or nearly sorted arrays.

## Linear Search
[Linear Search](/LinearSearch.java) is a search algorithm that iterates through a collection one element at a time to find a target element. It has a time complexity of O(n) and is suitable for small to medium-sized datasets, but inefficient for large datasets.

## Recursion
The [Recursion](/Recursion.java) class demonstrates various examples of recursive algorithms, including factorial calculation, string reversal, and a simple walk simulation.

## Contribution

Contributions to this documentation are welcome! If you have improvements, corrections, or additional examples to add, please feel free to submit a pull request.

Credits to My Java Sensei BroCode.